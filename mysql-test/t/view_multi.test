#
# QQ: Should we find a better place for this test?
#     May be binlog or rpl suites ?
#
--source include/have_log_bin.inc
--source include/have_binlog_format_mixed_or_statement.inc

#
# Bug #25144 "replication / binlog with view breaks".
# Statements that used views didn't ensure that view were not modified
# during their execution. Indeed this led to incorrect binary log with
# statement based logging.
#
--disable_parsing
drop table if not exists t1, t2;
drop view if exists v1;
--enable_parsing

# We are going to use binary log later to check that statements are
# logged in proper order, so it is good idea to reset it here.
reset master;

connect (addconn1,localhost,root,,);
connect (addconn2,localhost,root,,);
connection default;

create table t1 (i int);
create table t2 (i int);
create view v1 as select * from t1;

# First we try to concurrently execute statement that uses view
# and statement that drops it. We use "user" locks as means to
# suspend execution of first statement once it opens our view.
select get_lock("lock_bg25144", 1);

connection addconn1;
--send insert into v1 values (get_lock("lock_bg25144", 100));

connection addconn2;
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "User lock" and info like "insert into v1 %lock_bg25144%";
--source include/wait_condition.inc
--send drop view v1;

connection default;
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "drop view v1";
--source include/wait_condition.inc

select release_lock("lock_bg25144");

connection addconn1;
--reap
select release_lock("lock_bg25144");

connection addconn2;
--reap

connection default;
# Check that insertion through view did happen.
select * from t1;
# At the end of test we will check that statements were
# logged in proper order.

# Now we will repeat the test by trying concurrently execute
# statement that uses a view and statement that alters it.
create view v1 as select * from t1;

select get_lock("lock_bg25144", 1);

connection addconn1;
--send insert into v1 values (get_lock("lock_bg25144", 100));

connection addconn2;
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "User lock" and info like "insert into v1 %lock_bg25144%";
--source include/wait_condition.inc
--send alter view v1 as select * from t2;

connection default;
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and
  info = "alter view v1 as select * from t2";
--source include/wait_condition.inc

select release_lock("lock_bg25144");

connection addconn1;
--reap
select release_lock("lock_bg25144");

connection addconn2;
--reap

connection default;

# Second insertion should go to t1 as well.
select * from t1;
select * from t2;

# Now let us check that statements were logged in proper order
--replace_column 2 # 5 #
show binlog events in 'master-bin.000001' from 107;

drop table t1, t2;
drop view v1;
