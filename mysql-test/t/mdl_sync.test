#
# We need the Debug Sync Facility.
#
--source include/have_debug_sync.inc

# Save the initial number of concurrent sessions.
--source include/count_sessions.inc


# Clean up resources used in this test case.
--disable_warnings
SET DEBUG_SYNC= 'RESET';
--enable_warnings

#
# Test the case of when a exclusive lock request waits for a
# shared lock being upgraded to a exclusive lock.
#

connect (con1,localhost,root,,test,,);
connect (con2,localhost,root,,test,,);
connect (con3,localhost,root,,test,,);

connection default;

--disable_warnings
drop table if exists t1,t2,t3;
--enable_warnings

create table t1 (i int);
create table t2 (i int);

--echo connection: default
lock tables t2 read;

connection con1;
--echo connection: con1
set debug_sync='mdl_upgrade_shared_lock_to_exclusive SIGNAL parked WAIT_FOR go';
--send alter table t1 rename t3

connection default;
--echo connection: default
set debug_sync= 'now WAIT_FOR parked';

connection con2;
--echo connection: con2
set debug_sync='mdl_acquire_exclusive_locks_wait SIGNAL go';
--send drop table t1,t2

connection con1;
--echo connection: con1
--reap

connection default;
--echo connection: default
unlock tables;

connection con2;
--echo connection: con2
--error ER_BAD_TABLE_ERROR
--reap

connection default;
drop table t3;

disconnect con1;
disconnect con2;
disconnect con3;

# Clean up resources used in this test case.
--disable_warnings
SET DEBUG_SYNC= 'RESET';
--enable_warnings


--echo #
--echo # Test coverage for basic deadlock detection in metadata
--echo # locking subsystem.
--echo #
--disable_warnings
drop tables if exists t0, t1, t2, t3, t4, t5;
--enable_warnings

connect(deadlock_con1,localhost,root,,);
connect(deadlock_con2,localhost,root,,);
connect(deadlock_con3,localhost,root,,);
connection default;
create table t1 (i int);
create table t2 (j int);
create table t3 (k int);
create table t4 (k int);

--echo #
--echo # Test for the case in which no deadlock occurs.
--echo #

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
begin;
insert into t1 values (1);

--echo #
--echo # Switching to connection 'deadlock_con2'.
connection deadlock_con2;
begin;
insert into t2 values (1);

--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Send:
--send rename table t2 to t0, t3 to t2, t0 to t3;

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
--echo # Wait until the above RENAME TABLE is blocked because it has to wait
--echo # for 'deadlock_con2' which holds shared metadata lock on 't2'.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "rename table t2 to t0, t3 to t2, t0 to t3";
--source include/wait_condition.inc
--echo # The below statement should wait for exclusive metadata lock
--echo # on 't2' to go away and should not produce ER_LOCK_DEADLOCK
--echo # as no deadlock is possible in this situation.
--echo # Send:
--send select * from t2;

--echo #
--echo # Switching to connection 'deadlock_con2'.
connection deadlock_con2;
--echo # Wait until the above SELECT * FROM t2 is starts waiting
--echo # for an exclusive metadata lock to go away.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "select * from t2";
--source include/wait_condition.inc
--echo #
--echo # Unblock RENAME TABLE by releasing shared metadata lock on t2.
commit;

--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Reap RENAME TABLE.
--reap

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
--echo # Reap SELECT.
--reap

--echo #
--echo # Switching to connection 'default'.
connection default;
--echo #
--echo # Let us check that in the process of waiting for conflicting lock
--echo # on table 't2' to go away transaction in connection 'deadlock_con1'
--echo # has not released metadata lock on table 't1'.
--echo # Send:
--send rename table t1 to t0, t3 to t1, t0 to t3;

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
--echo # Wait until the above RENAME TABLE is blocked because it has to wait
--echo # for 'deadlock_con1' which should still hold shared metadata lock on
--echo # table 't1'.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "rename table t1 to t0, t3 to t1, t0 to t3";
--source include/wait_condition.inc
--echo # Commit transaction to unblock RENAME TABLE.
commit;

--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Reap RENAME TABLE.
--reap

--echo #
--echo # Test for case when deadlock occurs and should be detected immediately.
--echo #

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
begin;
insert into t2 values (2);

--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Send:
--send rename table t2 to t0, t1 to t2, t0 to t1;

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
--echo # Wait until the above RENAME TABLE is blocked because it has to wait
--echo # for 'deadlock_con1' which holds shared metadata lock on 't2'.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "rename table t2 to t0, t1 to t2, t0 to t1";
--source include/wait_condition.inc
--echo # 
--echo # The below statement should not wait as doing so will cause deadlock.
--echo # Instead it should fail and emit ER_LOCK_DEADLOCK statement.
--error ER_LOCK_DEADLOCK
select * from t1;

--echo #
--echo # Let us check that failure of the above statement has not released
--echo # metadata lock on table 't1', i.e. that RENAME TABLE is still blocked.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "rename table t2 to t0, t1 to t2, t0 to t1";
--source include/wait_condition.inc
--echo # Commit transaction to unblock RENAME TABLE.
commit;

--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Reap RENAME TABLE.
--reap

--echo #
--echo # Test for the case in which deadlock also occurs but not immediately.
--echo #

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
begin;
insert into t1 values (1);

--echo #
--echo # Switching to connection 'deadlock_con2'.
connection deadlock_con2;
begin;
insert into t3 values (1);

--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Send:
--send rename table t2 to t0, t3 to t2, t0 to t3;

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
--echo # Wait until the above RENAME TABLE is blocked because it has to wait
--echo # for 'deadlock_con2' which holds shared metadata lock on 't3'.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "rename table t2 to t0, t3 to t2, t0 to t3";
--source include/wait_condition.inc
--echo # The below SELECT statement should wait for metadata lock
--echo # on table 't2' and should not produce ER_LOCK_DEADLOCK
--echo # immediately as no deadlock is possible at the moment.
--send select * from t2;

--echo #
--echo # Switching to connection 'deadlock_con3'.
connection deadlock_con3;
--echo # Wait until the above SELECT * FROM t2 is starts waiting
--echo # for an exclusive metadata lock to go away.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "select * from t2";
--source include/wait_condition.inc

--echo # Send RENAME TABLE statement that will deadlock with the
--echo # SELECT statement and thus should abort the latter.
--send rename table t1 to t5, t2 to t1, t5 to t2;

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
--echo # Since the latest RENAME TABLE entered in deadlock with SELECT
--echo # statement the latter should be aborted and emit ER_LOCK_DEADLOCK
--echo # error.
--echo # Reap SELECT * FROM t2.
--error ER_LOCK_DEADLOCK
--reap

--echo #
--echo # Again let us check that failure of the SELECT statement has not
--echo # released metadata lock on table 't1', i.e. that the latest RENAME
--echo # is blocked.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "rename table t1 to t5, t2 to t1, t5 to t2";
--source include/wait_condition.inc
--echo # Commit transaction to unblock this RENAME TABLE.
commit;

--echo #
--echo # Switching to connection 'deadlock_con2'.
connection deadlock_con2;
--echo # Commit transaction to unblock the first RENAME TABLE.
commit;

--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Reap RENAME TABLE t2 TO t0 ... .
--reap

--echo #
--echo # Switching to connection 'deadlock_con3'.
connection deadlock_con3;
--echo # Reap RENAME TABLE t1 TO t5 ... .
--reap;

--echo #
--echo # Switching to connection 'default'.
connection default;

drop tables t1, t2, t3, t4;

--echo #
--echo # Now, test case which shows that deadlock detection empiric
--echo # also takes into account requests for metadata lock upgrade.
--echo #
create table t1 (i int);

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
begin;
insert into t1 values (1);

--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Send:
--send alter table t1 add column j int, rename to t2;

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
--echo # Wait until the above ALTER TABLE ... RENAME acquires exclusive
--echo # metadata lock on 't2' and starts waiting for connection
--echo # 'deadlock_con1' which holds shared lock on 't1'.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "alter table t1 add column j int, rename to t2";
--source include/wait_condition.inc

--echo # The below statement should not wait as it will cause deadlock.
--echo # An appropriate error should be reported instead.
--error ER_LOCK_DEADLOCK
select * from t2;

--echo # Again let us check that failure of the above statement has not
--echo # released all metadata locks in connection 'deadlock_con1' and
--echo # so ALTER TABLE ... RENAME is still blocked.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "alter table t1 add column j int, rename to t2";
--source include/wait_condition.inc

--echo # Commit transaction to unblock ALTER TABLE ... RENAME.
commit;

--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Reap ALTER TABLE ... RENAME.
--reap

drop table t2;

--echo #
--echo # Finally, test case in which deadlock (or potentially livelock) occurs
--echo # between metadata locking subsystem and table definition cache/table
--echo # locks, but which should still be detected by our empiric.
--echo #
create table t1 (i int);

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
begin;
insert into t1 values (1);

--echo #
--echo # Switching to connection 'default'.
connection default;
lock tables t1 write;

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
--echo # Send:
--send insert into t1 values (2);

--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Wait until INSERT in connection 'deadlock_con1' is blocked on
--echo # table-level lock.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Table lock" and info = "insert into t1 values (2)";
--source include/wait_condition.inc

--echo # Send:
--send alter table t1 add column j int;

--echo #
--echo # Switching to connection 'deadlock_con1'.
connection deadlock_con1;
--echo # The above ALTER TABLE statement should cause INSERT statement in
--echo # this connection to be aborted and emit ER_LOCK_DEADLOCK error.
--echo # Reap INSERT
--error ER_LOCK_DEADLOCK
--reap
--echo # Commit transaction to unblock ALTER TABLE.
commit;

--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Reap ALTER TABLE.
--reap
unlock tables;

drop table t1;
disconnect deadlock_con1;
disconnect deadlock_con2;
disconnect deadlock_con3;


--echo #
--echo # Test for bug #46748 "Assertion in MDL_context::wait_for_locks()
--echo # on INSERT + CREATE TRIGGER".
--echo #
--disable_warnings
drop tables if exists t1, t2, t3, t4, t5;
--enable_warnings
--echo # Let us simulate scenario in which we open some tables from extended
--echo # part of prelocking set but then encounter conflicting metadata lock,
--echo # so have to back-off and wait for it to go away.
connect (con1root,localhost,root,,test,,);
connect (con2root,localhost,root,,test,,);
connection default;
create table t1 (i int);
create table t2 (j int);
create table t3 (k int);
create table t4 (l int);
create trigger t1_bi before insert on t1 for each row
  insert into t2 values (new.i);
create trigger t2_bi before insert on t2 for each row
  insert into t3 values (new.j);
--echo #
--echo # Switching to connection 'con1root'.
connection con1root;
lock tables t4 read;
--echo #
--echo # Switching to connection 'con2root'.
connection con2root;
--echo # Send :
--send rename table t3 to t5, t4 to t3;
--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Wait until the above RENAME TABLE adds pending requests for exclusive
--echo # metadata lock on its tables and blocks due to 't4' being used by LOCK
--echo # TABLES.
let $wait_condition= select count(*)= 1 from information_schema.processlist
                       where state= 'Waiting for table' and
                             info='rename table t3 to t5, t4 to t3';
--source include/wait_condition.inc
--echo # Send :
--send insert into t1 values (1);
--echo #
--echo # Switching to connection 'con1root'.
connection con1root;
--echo # Wait until INSERT statement waits due to encountering pending
--echo # exclusive metadata lock on 't3'.
let $wait_condition= select count(*)= 1 from information_schema.processlist
                       where state= 'Waiting for table' and
                             info='insert into t1 values (1)';
--source include/wait_condition.inc
unlock tables;
--echo #
--echo # Switching to connection 'con2root'.
connection con2root;
--echo # Reap RENAME TABLE.
--reap
--echo #
--echo # Switching to connection 'default'.
connection default;
--echo # Reap INSERT.
--reap
--echo # Clean-up.
disconnect con1root;
disconnect con2root;
drop tables t1, t2, t3, t5;


--echo #
--echo # Bug#42546 - Backup: RESTORE fails, thinking it finds an existing table
--echo #

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings
set @save_log_output=@@global.log_output;
set global log_output=file;

connect(con2, localhost, root,,);

--echo #
--echo # Test 1: CREATE TABLE
--echo #

--echo # Connection 2 
connection con2;
--echo # Start insert on the not-yet existing table
--echo # Wait after taking the MDL lock
SET DEBUG_SYNC= 'after_open_table_mdl_shared SIGNAL locked WAIT_FOR finish';
--send INSERT INTO t1 VALUES(1,"def")

--echo # Connection 1
connection default;
SET DEBUG_SYNC= 'now WAIT_FOR locked';
--echo # Now INSERT has a MDL on the non-existent table t1.

--echo #
--echo # Continue the INSERT once CREATE waits for exclusive lock
SET DEBUG_SYNC= 'mdl_acquire_exclusive_locks_wait SIGNAL finish';
--echo # Try to create that table.
--send CREATE TABLE t1 (c1 INT, c2 VARCHAR(100), KEY(c1))

--echo # Connection 2
--echo # Insert fails
connection con2;
--error ER_NO_SUCH_TABLE
--reap

--echo # Connection 1
connection default;
--reap;
SET DEBUG_SYNC= 'RESET';
SHOW TABLES;

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings

--echo #
--echo # Test 2: CREATE TABLE LIKE
--echo #

CREATE TABLE t2 (c1 INT, c2 VARCHAR(100), KEY(c1));

--echo # Connection 2 
connection con2;
--echo # Start insert on the not-yet existing table
--echo # Wait after taking the MDL
SET DEBUG_SYNC= 'after_open_table_mdl_shared SIGNAL locked WAIT_FOR finish';
--send INSERT INTO t1 VALUES(1,"def")

--echo # Connection 1
connection default;
SET DEBUG_SYNC= 'now WAIT_FOR locked';
--echo # Now INSERT has a MDL on the non-existent table t1.

--echo #
--echo # Continue the INSERT once CREATE waits for exclusive lock
SET DEBUG_SYNC= 'mdl_acquire_exclusive_locks_wait SIGNAL finish';
--echo # Try to create that table.
--send CREATE TABLE t1 LIKE t2

--echo # Connection 2
--echo # Insert fails
connection con2;
--error ER_NO_SUCH_TABLE
--reap

--echo # Connection 1
connection default;
--reap
SET DEBUG_SYNC= 'RESET';
SHOW TABLES;

DROP TABLE t2;
disconnect con2;
--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings

set global log_output=@save_log_output;


--echo #
--echo # Bug #46044 "MDL deadlock on LOCK TABLE + CREATE TABLE HIGH_PRIORITY
--echo #             FOR UPDATE"
--echo #
--disable_warnings
drop tables if exists t1, t2;
--enable_warnings
connect (con46044, localhost, root,,);
connect (con46044_2, localhost, root,,);
connection default;
create table t1 (i int);

--echo # Let us check that we won't deadlock if during filling
--echo # of I_S table we encounter conflicting metadata lock
--echo # which owner is in its turn waiting for our connection.
lock tables t1 write;

--echo # Switching to connection 'con46044'.
connection con46044;
--echo # Sending:
--send create table t2 select * from t1;

--echo # Switching to connection 'default'.
connection default;
--echo # Waiting until CREATE TABLE ... SELECT ... is blocked.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Table lock" and info = "create table t2 select * from t1";
--source include/wait_condition.inc

--echo # First let us check that SHOW FIELDS/DESCRIBE doesn't
--echo # gets blocked and emits and error.
--error ER_WARN_I_S_SKIPPED_TABLE
show fields from t2;

--echo # Now test for I_S query which reads only .FRMs.
--echo #
--echo # Query below should only emit a warning.
select column_name from information_schema.columns
  where table_schema='test' and table_name='t2';

--echo # Finally, test for I_S query which does full-blown table open.
--echo #
--echo # Query below should not be blocked. Warning message should be
--echo # stored in the 'table_comment' column.
select table_name, table_type, auto_increment, table_comment
  from information_schema.tables where table_schema='test' and table_name='t2';

--echo # Switching to connection 'default'.
connection default;
unlock tables;

--echo # Switching to connection 'con46044'.
connection con46044;
--echo # Reaping CREATE TABLE ... SELECT ... .
--reap
drop table t2;

--echo #
--echo # Let us also check that queries to I_S wait for conflicting metadata
--echo # locks to go away instead of skipping table with a warning in cases
--echo # when deadlock is not possible. This is a nice thing from compatibility
--echo # and ease of use points of view.
--echo #
--echo # We check same three queries to I_S in this new situation.

--echo # Switching to connection 'con46044_2'.
connection con46044_2;
lock tables t1 write;

--echo # Switching to connection 'con46044'.
connection con46044;
--echo # Sending:
--send create table t2 select * from t1;

--echo # Switching to connection 'default'.
connection default;
--echo # Waiting until CREATE TABLE ... SELECT ... is blocked.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Table lock" and info = "create table t2 select * from t1";
--source include/wait_condition.inc

--echo # Let us check that SHOW FIELDS/DESCRIBE gets blocked.
--echo # Sending:
--send show fields from t2;

--echo # Switching to connection 'con46044_2'.
connection con46044_2;
--echo # Wait until SHOW FIELDS gets blocked.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "show fields from t2";
--source include/wait_condition.inc

unlock tables;

--echo # Switching to connection 'con46044'.
connection con46044;
--echo # Reaping CREATE TABLE ... SELECT ... .
--reap

--echo # Switching to connection 'default'.
connection default;
--echo # Reaping SHOW FIELDS ...
--reap
drop table t2;

--echo # Switching to connection 'con46044_2'.
connection con46044_2;
lock tables t1 write;

--echo # Switching to connection 'con46044'.
connection con46044;
--echo # Sending:
--send create table t2 select * from t1;

--echo # Switching to connection 'default'.
connection default;
--echo # Waiting until CREATE TABLE ... SELECT ... is blocked.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Table lock" and info = "create table t2 select * from t1";
--source include/wait_condition.inc

--echo # Check that I_S query which reads only .FRMs gets blocked.
--echo # Sending:
--send select column_name from information_schema.columns where table_schema='test' and table_name='t2';

--echo # Switching to connection 'con46044_2'.
connection con46044_2;
--echo # Wait until SELECT COLUMN_NAME FROM I_S.COLUMNS  gets blocked.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and
        info like "select column_name from information_schema.columns%";
--source include/wait_condition.inc

unlock tables;

--echo # Switching to connection 'con46044'.
connection con46044;
--echo # Reaping CREATE TABLE ... SELECT ... .
--reap

--echo # Switching to connection 'default'.
connection default;
--echo # Reaping SELECT COLUMN_NAME FROM I_S.COLUMNS
--reap
drop table t2;

--echo # Switching to connection 'con46044_2'.
connection con46044_2;
lock tables t1 write;

--echo # Switching to connection 'con46044'.
connection con46044;
--echo # Sending:
--send create table t2 select * from t1;

--echo # Switching to connection 'default'.
connection default;
--echo # Waiting until CREATE TABLE ... SELECT ... is blocked.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Table lock" and info = "create table t2 select * from t1";
--source include/wait_condition.inc

--echo # Finally, check that I_S query which does full-blown table open
--echo # also gets blocked.
--echo # Sending:
--send select table_name, table_type, auto_increment, table_comment from information_schema.tables where table_schema='test' and table_name='t2';

--echo # Switching to connection 'con46044_2'.
connection con46044_2;
--echo # Wait until SELECT ... FROM I_S.TABLES gets blocked.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and
        info like "select table_name, table_type, auto_increment, table_comment from information_schema.tables%";
--source include/wait_condition.inc

unlock tables;

--echo # Switching to connection 'con46044'.
connection con46044;
--echo # Reaping CREATE TABLE ... SELECT ... .
--reap

--echo # Switching to connection 'default'.
connection default;
--echo # Reaping SELECT ... FROM I_S.TABLES
--reap
drop table t2;

--echo # Switching to connection 'default'.
connection default;
--echo # Clean-up.
disconnect con46044;
disconnect con46044_2;
drop table t1;


--echo #
--echo # Test for bug #46273 "MySQL 5.4.4 new MDL: Bug#989 is not fully fixed
--echo #                      in case of ALTER".
--echo #
--disable_warnings
drop table if exists t1;
--enable_warnings
set debug_sync= 'RESET';
connect (con46273,localhost,root,,test,,);
connection default;
create table t1 (c1 int primary key, c2 int, c3 int);
insert into t1 values (1,1,0),(2,2,0),(3,3,0),(4,4,0),(5,5,0);

begin;
update t1 set c3=c3+1 where c2=3;

--echo #
--echo # Switching to connection 'con46273'.
connection con46273;
set debug_sync='after_lock_tables_takes_lock SIGNAL alter_table_locked WAIT_FOR alter_go';
--send alter table t1 add column e int, rename to t2;

--echo #
--echo # Switching to connection 'default'.
connection default;
set debug_sync='now WAIT_FOR alter_table_locked';
set debug_sync='wait_for_lock SIGNAL alter_go';
--echo # The below statement should get ER_LOCK_DEADLOCK error
--echo # (i.e. it should not allow ALTER to proceed, and then
--echo # fail due to 't1' changing its name to 't2').
--error ER_LOCK_DEADLOCK
update t1 set c3=c3+1 where c2=4;

--echo #
--echo # Let us check that failure of the above statement has not released
--echo # metadata lock on table 't1', i.e. that ALTER TABLE is still blocked.
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for table" and info = "alter table t1 add column e int, rename to t2";
--source include/wait_condition.inc

--echo # Unblock ALTER TABLE by commiting transaction and thus releasing
--echo # metadata lock on 't1'.
commit;

--echo #
--echo # Switching to connection 'con46273'.
connection con46273;
--echo # Reap ALTER TABLE.
--reap

--echo #
--echo # Switching to connection 'default'.
connection default;
disconnect con46273;
--echo # Clean-up.
set debug_sync= 'RESET';
drop table t2;


--echo #
--echo # Test for bug #46673 "Deadlock between FLUSH TABLES WITH READ LOCK
--echo #                      and DML".
--echo #
--disable_warnings
drop tables if exists t1;
--enable_warnings
connect (con46673, localhost, root,,);
connection default;
create table t1 (i int);

--echo # Switching to connection 'con46673'.
connection con46673;
begin;
insert into t1 values (1);

--echo # Switching to connection 'default'.
connection default;
--echo # Statement below should not get blocked. And if after some
--echo # changes to code it is there should not be a deadlock between
--echo # it and transaction from connection 'con46673'.
flush tables with read lock;
unlock tables;

--echo # Switching to connection 'con46673'.
connection con46673;
delete from t1 where i = 1;
commit;

--echo # Switching to connection 'default'.
connection default;
--echo # Clean-up
disconnect con46673;
drop table t1;


--echo #
--echo # Bug#48210 FLUSH TABLES WITH READ LOCK deadlocks 
--echo #           against concurrent CREATE PROCEDURE
--echo #

connect (con2, localhost, root);

--echo # Test 1: CREATE PROCEDURE

--echo # Connection 1
connection default;
--echo # Start CREATE PROCEDURE and open mysql.proc
SET DEBUG_SYNC= 'after_open_table_mdl_shared SIGNAL table_opened WAIT_FOR grlwait';
--send CREATE PROCEDURE p1() SELECT 1

--echo # Connection 2
connection con2;
SET DEBUG_SYNC= 'now WAIT_FOR table_opened';
--echo # Check that FLUSH must wait to get the GRL
--echo # and let CREATE PROCEDURE continue
SET DEBUG_SYNC= 'wait_lock_global_read_lock SIGNAL grlwait';
--send FLUSH TABLES WITH READ LOCK

--echo # Connection 1
connection default;
--reap

--echo # Connection 2
connection con2;
--reap
UNLOCK TABLES;

--echo # Connection 1
connection default;
SET DEBUG_SYNC= 'RESET';

--echo # Test 2: DROP PROCEDURE

connection default;
--echo # Start DROP PROCEDURE and open tables
SET DEBUG_SYNC= 'after_open_table_mdl_shared SIGNAL table_opened WAIT_FOR grlwait';
--send DROP PROCEDURE p1

--echo # Connection 2
connection con2;
SET DEBUG_SYNC= 'now WAIT_FOR table_opened';
--echo # Check that FLUSH must wait to get the GRL
--echo # and let DROP PROCEDURE continue
SET DEBUG_SYNC= 'wait_lock_global_read_lock SIGNAL grlwait';
--send FLUSH TABLES WITH READ LOCK

--echo # Connection 1
connection default;
--reap

--echo # Connection 2
connection con2;
--reap
UNLOCK TABLES;

--echo # Connection 1
connection default;
SET DEBUG_SYNC= 'RESET';

disconnect con2;


# Check that all connections opened by test cases in this file are really
# gone so execution of other tests won't be affected by their presence.
--source include/wait_until_count_sessions.inc
