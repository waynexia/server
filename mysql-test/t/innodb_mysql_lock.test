-- source include/have_innodb.inc

# Save the initial number of concurrent sessions.
--source include/count_sessions.inc

--echo #
--echo # Bug #22876 Four-way deadlock
--echo #

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings

connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connect (con3,localhost,root,,);

--echo # Connection 1
connection con1;
set @@autocommit=0;
CREATE TABLE t1(s1 INT UNIQUE) ENGINE=innodb;
INSERT INTO t1 VALUES (1);

--echo # Connection 2
connection con2;
set @@autocommit=0;
INSERT INTO t1 VALUES (2);
--send INSERT INTO t1 VALUES (1)

--echo # Connection 3
connection con3;
set @@autocommit=0;
--send DROP TABLE t1

--echo # Connection 1
connection con1;
let $wait_condition=
  SELECT COUNT(*) = 1 FROM information_schema.processlist
  WHERE info = "INSERT INTO t1 VALUES (1)" and 
  state = "update";
--source include/wait_condition.inc
let $wait_condition=
  SELECT COUNT(*) = 1 FROM information_schema.processlist
  WHERE info = "DROP TABLE t1" and 
  state = "Waiting for table";
--source include/wait_condition.inc
--echo # Connection 1 is now holding the lock.
--echo # Issuing insert from connection 1 while connection 2&3 
--echo # is waiting for the lock should give a deadlock error.
--error ER_LOCK_DEADLOCK
INSERT INTO t1 VALUES (2);

--echo # Cleanup
connection con2;
--reap
commit;
set @@autocommit=1;
connection con1;
commit;
set @@autocommit=1;
connection con3;
--reap
set @@autocommit=1;
connection default;

disconnect con1;
disconnect con3;

--echo #
--echo # Bug #42147 Concurrent DML and LOCK TABLE ... READ for InnoDB 
--echo #            table cause warnings in errlog
--echo #

--echo #
--echo # Note that this test for now relies on a global suppression of 
--echo # the warning "Found lock of type 6 that is write and read locked"
--echo # This suppression rule can be removed once Bug#42147 is properly
--echo # fixed. See bug page for more info.
--echo #

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings

CREATE TABLE t1 (i INT) engine= innodb;

--echo # Connection 2
--echo # Get user-level lock
connection con2;
SELECT get_lock('bug42147_lock', 60);

--echo # Connection 1
connection default;
--send INSERT INTO t1 SELECT get_lock('bug42147_lock', 60)

--echo # Connection 2
connection con2;
let $wait_condition=
  SELECT COUNT(*) > 0 FROM information_schema.processlist
  WHERE state = 'User lock' 
  AND info = 'INSERT INTO t1 SELECT get_lock(\'bug42147_lock\', 60)';
--source include/wait_condition.inc
LOCK TABLES t1 READ;
SELECT release_lock('bug42147_lock');

--echo # Connection 1
connection default;
--reap

--echo # Connection 2
connection con2;
UNLOCK TABLES;

--echo # Connection 1
connection default;
disconnect con2;
DROP TABLE t1;

# Check that all connections opened by test cases in this file are really
# gone so execution of other tests won't be affected by their presence.
--source include/wait_until_count_sessions.inc
